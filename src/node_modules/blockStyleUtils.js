// some functionality that is needed by Block.js but is related to styling (some things are also needed by Style.js)

var HashMap = require("hashmap")

var Style = require("./Style")
var utils = require('./utils')

var defaultStyleMap = new HashMap() // maps from a proto class to its computed default style
var computedStyles = new HashMap() // stores a map from styleMap components, to the combined style map


// gets the right style from the styleMap, depending on the block's `name` and `label` (`label` styles take precedence)
// takes the component's inheritance tree into account (relies on the block.constructor.parent property)
var getStyleMapEntryForBlock = exports.getStyleForComponent = function (styleMap, block) {
    if(styleMap === undefined)
        return undefined

    return getStyleForLabel(styleMap, block) || getStyleForBlockName(styleMap, block)
}

var getStyleForLabel = exports.getStyleForLabel = function(styleMap, block) {
    if(block.label !== undefined && '$'+block.label in styleMap) {
        return styleMap['$'+block.label]
    }
}
var getStyleForBlockName = exports.getStyleForBlockName = function(styleMap, block) {
    var constructor = block.constructor
    while(constructor !== undefined) {
        var style = styleMap[constructor.name]
        if(style !== undefined) {
            return style
        } else {
            constructor = constructor.parent
        }
    }
}

// gets the possibly inheriting style from the styleMap for `block`
// block - the block to get the style for
// ancestor - the block to get the computedStyleMap from
var getInheritingStyle = exports.getInheritingStyle = function(block, ancestor) {
    if(ancestor === undefined || ancestor.computedStyleMap === undefined) return undefined

    var labelStyle = getStyleForLabel(ancestor.computedStyleMap, block)
    if(labelStyle !== undefined) {
        if(labelStyle.inherit) {
            var inheritingBlockStyle = getInheritingBlockStyle(block, ancestor)
            return mixStyles(inheritingBlockStyle, labelStyle)
        } else {
            return labelStyle
        }
    } else {
        return getInheritingBlockStyle(block, ancestor)
    }


    // gets the inheriting style ignoring the first label style
    function getInheritingBlockStyle(block, ancestor) {
        var blockStyle = getStyleForBlockNameWithInheritance(ancestor.computedStyleMap, block)
        if(blockStyle !== undefined) {
            if(blockStyle.inherit) {
                return mixStyles(
                    getInheritingStyle(block, ancestor.parent),
                    blockStyle
                )
            } else {
                return blockStyle
            }
        } else {
            return undefined
        }
    }

    // like getStyleForBlockName, but mixes together styles in the styleMap as they inherit based on the block's ancestral names
    function getStyleForBlockNameWithInheritance(styleMap, block) {
        var styles = [];

        var constructor = block.constructor
        while(constructor !== undefined) {
            var style = styleMap[constructor.name]
            if(style !== undefined) {
                styles.push(style)
                if(!style.inherit) {
                    break;
                }
            }

            constructor = constructor.parent
        }

        var reversedStyles = styles.reverse() // reverse so later styles override earlier styles
        var styleToReturn = reversedStyles[0]
        for(var n=1; n<reversedStyles.length; n++) {
            styleToReturn = styleToReturn.mix(reversedStyles[n])
        }

        return styleToReturn
    }

}

// returns the conjunction of two style maps
// gets it from the computedStyles cache if its already in there
var styleMapConjunction = exports.styleMapConjunction = function (secondaryStyleMap, primaryStyleMap) {
    var cachedStyleMap = computedStyles.get([secondaryStyleMap, primaryStyleMap])
    if(cachedStyleMap === undefined) {
        if(secondaryStyleMap  === undefined) {
            cachedStyleMap = primaryStyleMap
        } else if(primaryStyleMap === undefined) {
            cachedStyleMap = secondaryStyleMap
        } else {
            var overridingProperties = {}, atLeastOne = false
            for(var key in primaryStyleMap) {
                if(secondaryStyleMap[key] !== primaryStyleMap[key]) {
                    overridingProperties[key] = primaryStyleMap[key]
                    atLeastOne = true
                }
            }

            if(atLeastOne) {
                cachedStyleMap = utils.objectConjunction(secondaryStyleMap, overridingProperties)
            } else { // the styleMaps are different objects, but contain the same thing
                cachedStyleMap = secondaryStyleMap
            }
        }

        if(cachedStyleMap === undefined) cachedStyleMap = false // switch it out with false so it can be recognized
        computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)
    }

    if(cachedStyleMap === false) {
        return undefined
    }
    return cachedStyleMap
}



exports.getDefaultStyle = function(block)  {
    // attempt to get from the cache
    var defaultBlockStyle = defaultStyleMap.get(block.constructor)
    if(defaultBlockStyle === undefined) {
        defaultBlockStyle = createDefaultBlockStyle(block)
        if(defaultBlockStyle === undefined) defaultBlockStyle = false
        defaultStyleMap.set(block.constructor, defaultBlockStyle)
    }

    if(defaultBlockStyle === false) {
        return undefined
    }
    return defaultBlockStyle
}

// returns a new style with style b mixed into style a (works even if they're both undefined)
var mixStyles = exports.mixStyles = function(a,b) {
    if(a === undefined)
        return b
    else
        return a.mix(b)
}





// sets the currentStyle of a block and makes all the appropriate changes to render a new active style for the block and its children
exports.setCurrentStyle = function(block, newCurrentStyle, defaultStyle) {

    var current$state = block._currentStyle === undefined? undefined: block._currentStyle.stateHandler
    var newCurrentStyle$state = newCurrentStyle === undefined? undefined: newCurrentStyle.stateHandler
    if(current$state !== newCurrentStyle$state) {     // if the $state function remains the same, we don't gotta do nothin (about switching state functions at least)
        if(block._stateChangeHandler !== undefined) {  // remove the old handler if necessary
            block.state.removeListener('change', block._stateChangeHandler)
            block._stateChangeHandler = undefined
        }

        if(newCurrentStyle$state !== undefined) {     // add a new handler if necessary
            block.state.on('change', block._stateChangeHandler = function() {
                var rawStateStyle = getStateStyle(block._currentStyle, block.state.subject)
                setMixedStateStyle(block, mixStyles(block._currentStyle, rawStateStyle))
            })
        }
    }

    block._currentStyle = newCurrentStyle
    var rawStateStyle = getStateStyle(newCurrentStyle, block.state.subject)

    var newMixedStateStyle = mixStyles(newCurrentStyle, rawStateStyle)
    setMixedStateStyle(block, newMixedStateStyle, defaultStyle)
}


// handles reseting a block's active style when its state style changes
// renders the pseudoclass style
function setMixedStateStyle(block, mixedStateStyle, defaultStyle) {
    var psuedoclassState = {}

    // if a pseudoclass can no longer apply, undo its setup
    for(var pseudoClass in block._styleSetupInfo) {
        if(mixedStateStyle === undefined || !(pseudoClass in mixedStateStyle.pseudoclasses.emulatedInfo)) {
            var setupInfo = block._styleSetupInfo[pseudoClass]
            setupInfo.kill(block, setupInfo.state)
            delete block._styleSetupInfo[pseudoClass]
        }
    }

    // setup new pseudoclasses
    if(mixedStateStyle !== undefined) {
        for(var pseudoClass in mixedStateStyle.pseudoclasses.emulatedInfo) {
            if(!(pseudoClass in block._styleSetupInfo)) {                     // if this exact pseudoclass is already setup, no need to do anything
                ;(function(pseudoClass, emulationInfo){   // close over those variables (so they keep the value they had when the function was setup)
                    var setupState = emulationInfo.fns.setup(block, function() { // start
                        var changed = psuedoclassState[pseudoClass] !== true
                        if(changed) {
                            psuedoclassState[pseudoClass] = true
                            changeStyleIfNecessary()
                        }
                    }, function() { // end
                        var changed = psuedoclassState[pseudoClass] !== false
                        if(changed) {
                            psuedoclassState[pseudoClass] = false
                            changeStyleIfNecessary()
                        }
                    }, emulationInfo.parameter)

                    block._styleSetupInfo[pseudoClass] = {state: setupState, kill: emulationInfo.fns.kill}

                })(pseudoClass, mixedStateStyle.pseudoclasses.emulatedInfo[pseudoClass])
            }
        }
    }

    // build up the pseudoclass state - depending on what pseudoclasses might become applicable
    if(mixedStateStyle !== undefined) {
        for(var pseudoclassKey in mixedStateStyle.pseudoclasses.emulatedInfo) {
            var info = mixedStateStyle.pseudoclasses.emulatedInfo[pseudoclassKey]
            psuedoclassState[pseudoclassKey] = info.fns.check(block, info.parameter)
        }
    }

    // set current pseudoclass style
    changeStyleIfNecessary()


    function changeStyleIfNecessary() {
        var pseudoclassStyleInfo = getPseudoclassStyleFor(mixedStateStyle, psuedoclassState)
        var newPreStyleMapStyle = mixStyles(mixedStateStyle, pseudoclassStyleInfo.style)
        setPreStyleMapStyle(block, newPreStyleMapStyle, pseudoclassStyleInfo.index, defaultStyle)
    }
}

// sets the style before being modified by the block's parent's computedStyleMap
// handles removing the state listener and calling $kill on the old activeStyle
function setPreStyleMapStyle(block, newPreStyleMapStyle, jsRenderedPseudoclassIndex, defaultStyle) {
    if(block.parent !== undefined && newPreStyleMapStyle !== undefined)
        var newComputedStyleMap = styleMapConjunction(block.parent.computedStyleMap, newPreStyleMapStyle.componentStyleMap)
    else if(block.parent !== undefined)
        var newComputedStyleMap = block.parent.computedStyleMap
    else if(newPreStyleMapStyle !== undefined)
        var newComputedStyleMap = newPreStyleMapStyle.componentStyleMap
    else
        var newComputedStyleMap = undefined

    var newActiveStyle = undefined // can be changed below
    var cancel = false
    if(newPreStyleMapStyle !== undefined) {
        if(block.parent !== undefined) var nativePseudoclassMap = block.parent._nativePseudoclassMap
        else                           var nativePseudoclassMap = {}

        var nativePseudoclassSelectorMap = getStyleMapEntryForBlock(nativePseudoclassMap, block)
        var nativeCssInfo = newPreStyleMapStyle.createNativeCssInfo(newComputedStyleMap, nativePseudoclassSelectorMap, jsRenderedPseudoclassIndex, defaultStyle)

        if(nativeCssInfo.cancel) {
            cancel = true
            setMixedStateStyle(block, nativeCssInfo.retryStyle)

        } else {
            newActiveStyle = nativeCssInfo.style
            newComputedStyleMap = nativeCssInfo.styleMap // even newer!
            block._nativePseudoclassMap = nativeCssInfo.nativePseudoclassMap
        }
    }

    if(!cancel) {
        setActiveStyle(block, newActiveStyle, newComputedStyleMap)
    }
}

// sets the active style on the block and on the block's children
// also sets the block's new computedStyleMap
function setActiveStyle(block, newActiveStyle, newComputedStyleMap) {
    var activeStyleChanged = newActiveStyle !== block._activeStyle
    var computedStyleMapChanged = block.computedStyleMap !== newComputedStyleMap

    if(activeStyleChanged) {
        setStyleClass(block, newActiveStyle)

        var curActiveStyle$setup = block._activeStyle === undefined? undefined: block._activeStyle.setup
        var newActiveStyle$setup = newActiveStyle === undefined? undefined: newActiveStyle.setup
        if(curActiveStyle$setup !== newActiveStyle$setup) {
            applyStyleKillFunction(block)
            applyStyleSetupFunction(block, newActiveStyle)
        }

        block._activeStyle = newActiveStyle
    }


    block.computedStyleMap = newComputedStyleMap

    // propogate styles to children
    block.children.forEach(function(child) {
        if(computedStyleMapChanged || !child.attached) {
            child.attached = true
            child.style = child.style  // force a re-render on each child
        }
    })
}



// given a style and an object representing some state, returns the state given by the style's $state function
// returns undefined if it doesn't have a state function
// handles caching state styles (an optimization)
function getStateStyle(currentStyle, stateParameter) {
    if(currentStyle === undefined || currentStyle.stateHandler === undefined) return undefined

    var returnedStyle = currentStyle.stateHandler(stateParameter)

    // todo: figure out if this style has been returned before, and if so, use the already-generated style (mostly so that that style can take advantage of other cached combinations)

    return returnedStyle
}

// returns an object with the properties:
    // style - the jsRendered pseudoclass style for the block's relevant pseudoclass state
    // index - the index of the pseudoclass (jsRenderedPseudoclassIndex)
// returns undefined if no emulated pseudoclass style applies or if only native pseudoclass stylings apply
// state - an object that will be mutated with the current state for each pseudoclass
function getPseudoclassStyleFor(style, state) {
    if(style === undefined) return {index:0}

    var index = 0, result={index:0}
    style.pseudoclasses.classes.forEach(function(psuedoclassStyle, compoundKey) {
        if(!psuedoclassStyle.pureNative) {
            for(var j=0; j<compoundKey.length; j++) {
                var pseudoclass = compoundKey[j]
                if(!state[pseudoclass]) {
                    break;
                }
            }

            if(j === compoundKey.length) {
                result = {index: index, style: psuedoclassStyle}
            }
        }

        index++
    })

    return result
}



// finds the default style for a block, mixes it with the appropriate ancestor styles, and returns the result
function createDefaultBlockStyle(that) {
    if(that.defaultStyle !== undefined) {
        validateDefaultStyle(that.defaultStyle)
    }

    // get list of default styles
    var defaultStyles = []
    var nextConstructor = that.constructor
    while(nextConstructor !== undefined) {
        if(nextConstructor.defaultStyle !== undefined) {
            defaultStyles.push(nextConstructor.defaultStyle)
        }
        nextConstructor = nextConstructor.parent
    }

    // generate merged default style
    var reversedDefaults = defaultStyles.reverse()
    var mergedDefaultStyle = reversedDefaults[0]
    for(var n=1; n<reversedDefaults.length; n++) {
        mergedDefaultStyle = mergedDefaultStyle.mix(reversedDefaults[n])
    }

    return mergedDefaultStyle
}


// applies setup appropriately
function applyStyleSetupFunction(component, style) {
    if(style !== undefined && style.setup !== undefined) {
        component._styleSetupObject = style.setup(component) // call setup on the component
    } else {
        component._styleSetupObject = undefined
    }
}
// applies kill appropriately
function applyStyleKillFunction(component) {
    var activeStyle = component._activeStyle
    if(activeStyle !== undefined && activeStyle.setup !== undefined) {
        if(activeStyle.kill === undefined)
            throw new Error('style has been unset but does not have a "kill" function to undo its "setup" function')

        activeStyle.kill(component, component._styleSetupObject)
    }
}


// sets the style, replacing one if one already exists
function setStyleClass(component, style) {
    var activeStyle = component._activeStyle

    var newStyle = component.domNode.className
    if(activeStyle !== undefined) {
        newStyle = newStyle.replace(new RegExp(" ?\\b"+activeStyle.className+"\\b"),'') // remove the previous css class
    }
    if(style !== undefined) {
        newStyle = style.className+' '+newStyle.trim() // note that the order of classes doesn't matter
    }

    component.domNode.className = newStyle
}

function validateDefaultStyle(defaultStyle) {
    if(!isStyleObject(defaultStyle)) {
        throw new Error("defaultStyle property must be a Style object")
    }
}

// if you load two different instances of blocks, its necessary to do a bit of duck typing
function isStyleObject(x) {
    return x.className !== undefined && x.componentStyleMap !== undefined && x.mix !== undefined
}